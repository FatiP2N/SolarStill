# -*- coding: utf-8 -*-
"""radiation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c584OT8xI9biXV3HvNq5sE6E6NzMY8Jp
"""

pip install pysolar

#le bon code"
from pysolar.solar import *
import math
from datetime import datetime
import datetime
import pandas as pd

# Paramètres du site
sum_I=0
h0=7 #levé du soleil!!!
hf=22 # couché du soleil!!!
latitude = 32.5917  # Latitude du site
longitude = 7.36269
theta_g = 30.0  # Inclinaison de la surface (en degrés)
alb = 0.17  # Albedo soil
dm=31 # day in mounth!!!!
# Moyennes mensuelles pour DNI et GHI214	185	217

DNI_monthly = 237*1000/dm  # Moyenne mensuelle (en W/m²)!!!!
GHI_monthly = 201*1000/dm  # Moyenne mensuelle (en W/m²)!!!
GTI=222 #kwh/m2
# Facteur de distribution horaire (simplifié, basé sur l'angle solaire)
def facteur_distribution(h):
    h_milieu = (h0 + hf) / 2
    return max(0, math.sin(math.pi * (h - h0) / (hf - h0)))

# Fonction pour calculer la déclinaison solaire
def declinaison(n):
    return 23.45 * math.sin(math.radians(360 / 365 * (n - 81)))

# Fonction pour cos(theta_i)
def cos_theta_i(phi, delta, theta_g, gamma, h):
    phi, delta, theta_g, gamma, h = map(math.radians, [phi, delta, theta_g, gamma, h])
    return (math.sin(delta) * (math.sin(phi) * math.cos(theta_g) - math.cos(phi) * math.sin(theta_g) * math.cos(gamma)) +
            math.cos(delta) * (math.cos(phi) * math.cos(theta_g) * math.cos(h) +
                               math.sin(phi) * math.sin(theta_g) * math.cos(gamma) +
                               math.sin(theta_g) * math.sin(gamma) * math.sin(h)))

# Fonction pour cos(theta_z)
def cos_theta_z(phi, delta, h):
    phi, delta, h = map(math.radians, [phi, delta, h])
    return math.sin(phi) * math.sin(delta) + math.cos(phi) * math.cos(delta) * math.cos(h)

# Répartition des heures
hours = range(h0, hf)
date_str = "19/07/2024"  # date!!!!!
date = datetime.datetime.strptime(date_str, "%d/%m/%Y")
n = date.timetuple().tm_yday
sheet_ = date.strftime("%d-%m-%Y")

# Calcul de la somme des facteurs horaires
sum_factors = sum(facteur_distribution(h) for h in hours)
irr=[]
# Calcul des irradiances horaires
for h in hours:
    factor = facteur_distribution(h) / sum_factors

    GHI_hourly = GHI_monthly * factor
    DNI_hourly = DNI_monthly * factor
    delta = declinaison(n)
    h_angle = 15 * (h - 12)  # Angle horaire

    # Construire un objet datetime pour chaque heure
    dt = datetime.datetime(
        year=date.year,
        month=date.month,
        day=date.day,
        hour=h,
        minute=0,  # Valeur fixe d'exemple
        second=0,   # Valeur fixe d'exemple
        microsecond=1,  # Valeur fixe d'exemple
        tzinfo=datetime.timezone.utc  # Ajout du fuseau horaire UTC
    )


# Afficher les résultats

    cos_theta = cos_theta_i(latitude, delta, theta_g, get_azimuth(latitude, longitude, dt), h_angle)
    cos_z = cos_theta_z(latitude, delta, h_angle)

    # Calcul de l'irradiation inclinée
    I = max(DNI_hourly * cos_theta + GHI_hourly * (
        (1 + math.cos(math.radians(theta_g))) / 2 + alb * (1 - math.cos(math.radians(theta_g))) / 2), 0)
    sum_I+=I
    irr.append(I)
    #print(f"Heure {h}h : GHI = {GHI_hourly:.2f} W/m², DNI = {DNI_hourly:.2f} W/m², I = {I:.2f} W/m²")
Time=[h for h in range (h0,hf)]

total_I_kWh = sum_I * dm / 1000
correction_factor = GTI / total_I_kWh
irr_corrected = [I * correction_factor for I in irr]  # Ajustement final

radiation= pd.DataFrame({'Time': Time, 'I': irr_corrected})
with pd.ExcelWriter("IR.xlsx", engine="openpyxl", mode="a", if_sheet_exists="overlay") as writer: radiation.to_excel(writer, sheet_name=sheet_, index=False)


print("Calcul et enregistrement terminés.",GTI- sum_I*dm/1000)
radiation



